#!/usr/bin/env groovy
/*
 * Enterprise Finacle CI/CD Pipeline
 * Version: 1.0.0
 * Supports: DEV, QA, UAT, PRODUCTION branches
 * Organizations: Sampath Bank, AFC, Siyapatha Finance, PABC
 */

@Library('finacle-shared-lib') _

// Pipeline Configuration
def REPO_URL = 'https://github.com/ArunaluB/Linearsix-Finacle-Git-Demo.git'
def FINACLE_SERVER = 'findem.linear6.com'
def FINACLE_USER = 'finadm'
def BASE_PATH = '/finapp/FIN/DEM/BE/Finacle/FC/app/cust/01/INFENG'
def PATCH_BASE = '/finutils/customizations'
def FINAL_DELIVERY = '/finutils/customizations_10225/Localizations/FinalDelivery'

pipeline {
    agent any
    
    parameters {
        choice(
            name: 'DEPLOYMENT_MODE',
            choices: ['JENKINS_AUTO', 'LOCAL_PC_MANUAL'],
            description: 'Deployment Mode Selection'
        )
        string(
            name: 'TICKET_NUMBER',
            defaultValue: '',
            description: 'Patch/Ticket Number (e.g., 10225)'
        )
        string(
            name: 'FIN_INSTALL_ID',
            defaultValue: 'FINDEM',
            description: 'Finacle Installation ID'
        )
        booleanParam(
            name: 'FORCE_ROLLBACK',
            defaultValue: false,
            description: 'Force rollback to previous version'
        )
    }
    
    environment {
        BRANCH_NAME = "${env.GIT_BRANCH?.replaceAll('origin/', '')}"
        DEPLOYMENT_ENV = "${getBranchEnvironment(env.GIT_BRANCH)}"
        SSH_KEY = credentials('finacle-ssh-key')
        EMAIL_RECIPIENTS = credentials('finacle-email-list')
        AUDIT_LOG_DIR = "/var/log/finacle-deployments"
        TIMESTAMP = "${new Date().format('yyyyMMdd_HHmmss')}"
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '50'))
        timeout(time: 2, unit: 'HOURS')
        timestamps()
        disableConcurrentBuilds()
    }
    
    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "=== FINACLE CI/CD PIPELINE INITIALIZATION ==="
                    echo "Branch: ${BRANCH_NAME}"
                    echo "Environment: ${DEPLOYMENT_ENV}"
                    echo "Ticket: ${params.TICKET_NUMBER}"
                    echo "Build: ${BUILD_NUMBER}"
                    echo "Commit: ${GIT_COMMIT}"
                    
                    // Validate branch protection
                    if (DEPLOYMENT_ENV in ['QA', 'UAT', 'PRODUCTION']) {
                        if (!isApprovedForEnvironment(DEPLOYMENT_ENV)) {
                            error("Branch ${BRANCH_NAME} requires approval for ${DEPLOYMENT_ENV}")
                        }
                    }
                    
                    // Initialize audit logging
                    sh """
                        ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no ${FINACLE_USER}@${FINACLE_SERVER} \
                        'mkdir -p ${AUDIT_LOG_DIR}'
                    """
                }
            }
        }
        
        stage('Pre-deployment Validation') {
            steps {
                script {
                    echo "=== PRE-DEPLOYMENT VALIDATION ==="
                    
                    // Clean up previous deployment folders
                    sh """
                        bash ${WORKSPACE}/ci-cd/scripts/cleanup_previous_deployment.sh \
                            --environment ${DEPLOYMENT_ENV} \
                            --ticket ${params.TICKET_NUMBER}
                    """
                    
                    // Validate file headers in appserver directory
                    sh """
                        cd ${WORKSPACE}/appserver
                        bash ${WORKSPACE}/ci-cd/scripts/validate_file_headers.sh
                    """
                    
                    // Check for merge conflicts (QA branch)
                    if (DEPLOYMENT_ENV == 'QA') {
                        def conflicts = sh(
                            script: "git diff --name-only --diff-filter=U",
                            returnStdout: true
                        ).trim()
                        
                        if (conflicts) {
                            emailext(
                                subject: "MERGE CONFLICT DETECTED - ${TICKET_NUMBER}",
                                body: """
                                    Merge Conflict in QA Branch
                                    
                                    Ticket: ${params.TICKET_NUMBER}
                                    Branch: ${BRANCH_NAME}
                                    Conflicts: ${conflicts}
                                    Author: ${env.BUILD_USER}
                                    
                                    Please resolve conflicts before proceeding.
                                """,
                                to: "${EMAIL_RECIPIENTS}",
                                attachLog: true
                            )
                            error("Merge conflicts detected. Deployment aborted.")
                        }
                    }
                    
                    // Extract changed files from appserver directory
                    def changedFiles = sh(
                        script: "git diff --name-only HEAD~1 HEAD | grep '^appserver/' || true",
                        returnStdout: true
                    ).trim()
                    
                    echo "Changed Files in appserver/:\n${changedFiles}"
                    env.CHANGED_FILES = changedFiles
                }
            }
        }
        
        stage('Create Patch Structure') {
            when {
                expression { DEPLOYMENT_ENV in ['QA', 'UAT'] }
            }
            steps {
                script {
                    echo "=== CREATING PATCH STRUCTURE ==="
                    
                    sh """
                        bash ${WORKSPACE}/ci-cd/scripts/create_patch_structure.sh \
                            --ticket ${params.TICKET_NUMBER} \
                            --install-id ${params.FIN_INSTALL_ID} \
                            --environment ${DEPLOYMENT_ENV}
                    """
                }
            }
        }
        
        stage('Cleanup Developer Versions (QA Only)') {
            when {
                expression { DEPLOYMENT_ENV == 'QA' }
            }
            steps {
                script {
                    echo "=== CLEANING UP DEVELOPER VERSIONS IN QA ==="
                    
                    // Clean up developer-named files (nirasha_payoff.scr, harsha_payoff.scr)
                    // Keep only canonical files (payoff.scr)
                    sh """
                        bash ${WORKSPACE}/ci-cd/scripts/cleanup_dev_versions_qa.sh \
                            --ticket ${params.TICKET_NUMBER} \
                            --type scr
                        
                        bash ${WORKSPACE}/ci-cd/scripts/cleanup_dev_versions_qa.sh \
                            --ticket ${params.TICKET_NUMBER} \
                            --type sql
                        
                        bash ${WORKSPACE}/ci-cd/scripts/cleanup_dev_versions_qa.sh \
                            --ticket ${params.TICKET_NUMBER} \
                            --type com
                    """
                }
            }
        }
        
        stage('Approval Gate - QA') {
            when {
                expression { DEPLOYMENT_ENV == 'QA' }
            }
            steps {
                script {
                    def qaApproval = input(
                        message: 'QA Deployment Approval Required',
                        parameters: [
                            string(name: 'APPROVER', description: 'Your Name'),
                            text(name: 'COMMENTS', description: 'Approval Comments')
                        ],
                        submitter: 'qa-leads',
                        submitterParameter: 'APPROVED_BY'
                    )
                    
                    echo "QA Approved by: ${qaApproval.APPROVER}"
                    env.QA_APPROVER = qaApproval.APPROVER
                }
            }
        }
        
        stage('Approval Gate - UAT') {
            when {
                expression { DEPLOYMENT_ENV == 'UAT' }
            }
            steps {
                script {
                    def uatApproval = input(
                        message: 'UAT Deployment Approval Required',
                        parameters: [
                            string(name: 'APPROVER', description: 'QA Lead Name'),
                            text(name: 'COMMENTS', description: 'UAT Approval Comments')
                        ],
                        submitter: 'qa-leads',
                        submitterParameter: 'APPROVED_BY'
                    )
                    
                    echo "UAT Approved by: ${uatApproval.APPROVER}"
                    env.UAT_APPROVER = uatApproval.APPROVER
                }
            }
        }
        
        stage('Approval Gate - PRODUCTION') {
            when {
                expression { DEPLOYMENT_ENV == 'PRODUCTION' }
            }
            steps {
                script {
                    def prodApproval = input(
                        message: 'PRODUCTION Deployment Approval Required',
                        parameters: [
                            string(name: 'TECH_LEAD', description: 'Tech Lead Name'),
                            booleanParam(name: 'CONFIRMED', description: 'I confirm production deployment'),
                            text(name: 'COMMENTS', description: 'Production Approval Comments')
                        ],
                        submitter: 'tech-leads',
                        submitterParameter: 'APPROVED_BY'
                    )
                    
                    if (!prodApproval.CONFIRMED) {
                        error("Production deployment not confirmed")
                    }
                    
                    echo "PRODUCTION Approved by: ${prodApproval.TECH_LEAD}"
                    env.PROD_APPROVER = prodApproval.TECH_LEAD
                }
            }
        }
        
        stage('Backup Current Version') {
            steps {
                script {
                    echo "=== BACKING UP CURRENT VERSION ==="
                    
                    sh """
                        bash ${WORKSPACE}/ci-cd/scripts/backup_files.sh \
                            --environment ${DEPLOYMENT_ENV} \
                            --ticket ${params.TICKET_NUMBER} \
                            --timestamp ${TIMESTAMP}
                    """
                }
            }
        }
        
        stage('Deploy Files') {
            steps {
                script {
                    echo "=== DEPLOYING FILES TO ${DEPLOYMENT_ENV} ==="
                    
                    // Parse changed files and deploy by extension
                    def files = env.CHANGED_FILES.split('\n')
                    
                    for (file in files) {
                        // Only deploy files from appserver directory
                        if (!file.startsWith('appserver/')) {
                            echo "Skipping non-appserver file: ${file}"
                            continue
                        }
                        
                        def extension = file.tokenize('.').last()
                        def fullPath = "${WORKSPACE}/${file}"
                        
                        echo "Deploying: ${file} (${extension})"
                        
                        switch(extension) {
                            case 'scr':
                                sh """
                                    bash ${WORKSPACE}/ci-cd/scripts/deploy_scr.sh \
                                        --file ${fullPath} \
                                        --environment ${DEPLOYMENT_ENV} \
                                        --ticket ${params.TICKET_NUMBER}
                                """
                                break
                            case 'sql':
                                sh """
                                    bash ${WORKSPACE}/ci-cd/scripts/deploy_sql.sh \
                                        --file ${fullPath} \
                                        --environment ${DEPLOYMENT_ENV} \
                                        --ticket ${params.TICKET_NUMBER}
                                """
                                break
                            case 'com':
                            case 'mrt':
                                sh """
                                    bash ${WORKSPACE}/ci-cd/scripts/deploy_com_mrt.sh \
                                        --file ${fullPath} \
                                        --environment ${DEPLOYMENT_ENV} \
                                        --ticket ${params.TICKET_NUMBER}
                                """
                                break
                            default:
                                echo "Skipping unsupported file type: ${extension}"
                        }
                    }
                }
            }
        }
        
        stage('FINL Validation') {
            steps {
                script {
                    echo "=== RUNNING FINL VALIDATION ==="
                    
                    def finlResult = sh(
                        script: """
                            ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no ${FINACLE_USER}@${FINACLE_SERVER} \
                            'bash /home/${FINACLE_USER}/scripts/run_finl.sh ${params.FIN_INSTALL_ID}'
                        """,
                        returnStatus: true
                    )
                    
                    if (finlResult != 0) {
                        error("FINL validation failed. Initiating rollback...")
                    }
                    
                    echo "FINL validation successful"
                }
            }
        }
        
        stage('Service Restart') {
            steps {
                script {
                    echo "=== RESTARTING FINACLE SERVICES ==="
                    
                    sh """
                        ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no ${FINACLE_USER}@${FINACLE_SERVER} \
                        'bash /home/${FINACLE_USER}/scripts/restart_services.sh ${params.FIN_INSTALL_ID}'
                    """
                    
                    // Wait for service to be ready
                    sleep(time: 30, unit: 'SECONDS')
                }
            }
        }
        
        stage('Post-Deployment Verification') {
            steps {
                script {
                    echo "=== POST-DEPLOYMENT VERIFICATION ==="
                    
                    sh """
                        bash ${WORKSPACE}/ci-cd/scripts/verify_deployment.sh \
                            --environment ${DEPLOYMENT_ENV} \
                            --ticket ${params.TICKET_NUMBER}
                    """
                }
            }
        }
        
        stage('Production Branch Synchronization') {
            when {
                expression { DEPLOYMENT_ENV == 'PRODUCTION' }
            }
            steps {
                script {
                    echo "=== SYNCHRONIZING ALL BRANCHES WITH PRODUCTION ==="
                    
                    sh """
                        bash ${WORKSPACE}/ci-cd/scripts/sync_branches_from_production.sh
                    """
                }
            }
        }
        
        stage('Generate Audit Report') {
            steps {
                script {
                    echo "=== GENERATING AUDIT REPORT ==="
                    
                    sh """
                        bash ${WORKSPACE}/ci-cd/scripts/generate_audit_log.sh \
                            --environment ${DEPLOYMENT_ENV} \
                            --ticket ${params.TICKET_NUMBER} \
                            --commit ${GIT_COMMIT} \
                            --author "${env.BUILD_USER}" \
                            --timestamp ${TIMESTAMP} \
                            --approver "${env.PROD_APPROVER ?: env.UAT_APPROVER ?: env.QA_APPROVER ?: 'AUTO'}"
                    """
                }
            }
        }
    }
    
    post {
        success {
            script {
                emailext(
                    subject: "✓ Finacle Deployment SUCCESS - ${DEPLOYMENT_ENV} - Ticket ${params.TICKET_NUMBER}",
                    body: """
                        Finacle Deployment Completed Successfully
                        
                        Environment: ${DEPLOYMENT_ENV}
                        Ticket: ${params.TICKET_NUMBER}
                        Branch: ${BRANCH_NAME}
                        Commit: ${GIT_COMMIT}
                        Build: ${BUILD_NUMBER}
                        Author: ${env.BUILD_USER}
                        Approver: ${env.PROD_APPROVER ?: env.UAT_APPROVER ?: env.QA_APPROVER ?: 'AUTO'}
                        Timestamp: ${TIMESTAMP}
                        
                        Files Deployed:
                        ${env.CHANGED_FILES}
                        
                        Status: SUCCESSFUL
                    """,
                    to: "${EMAIL_RECIPIENTS}",
                    attachLog: true
                )
            }
        }
        
        failure {
            script {
                echo "=== DEPLOYMENT FAILED - INITIATING ROLLBACK ==="
                
                sh """
                    bash ${WORKSPACE}/ci-cd/scripts/rollback_deployment.sh \
                        --environment ${DEPLOYMENT_ENV} \
                        --ticket ${params.TICKET_NUMBER} \
                        --timestamp ${TIMESTAMP}
                """
                
                emailext(
                    subject: "✗ Finacle Deployment FAILED - ${DEPLOYMENT_ENV} - Ticket ${params.TICKET_NUMBER}",
                    body: """
                        Finacle Deployment Failed - Rollback Initiated
                        
                        Environment: ${DEPLOYMENT_ENV}
                        Ticket: ${params.TICKET_NUMBER}
                        Branch: ${BRANCH_NAME}
                        Commit: ${GIT_COMMIT}
                        Build: ${BUILD_NUMBER}
                        Author: ${env.BUILD_USER}
                        Timestamp: ${TIMESTAMP}
                        
                        Status: FAILED - ROLLED BACK
                        
                        Please review build log for details.
                    """,
                    to: "${EMAIL_RECIPIENTS}",
                    attachLog: true
                )
            }
        }
        
        always {
            script {
                cleanWs()
            }
        }
    }
}

// Helper Functions
def getBranchEnvironment(branchName) {
    if (!branchName) return 'DEV'
    
    branchName = branchName.replaceAll('origin/', '')
    
    switch(branchName) {
        case 'PRODUCTION':
            return 'PRODUCTION'
        case 'UAT':
            return 'UAT'
        case 'QA':
            return 'QA'
        case 'DEV':
            return 'DEV'
        case ~/^DEV-.*/:
            return 'DEV'
        default:
            return 'DEV'
    }
}

def isApprovedForEnvironment(env) {
    // Implement approval logic based on environment
    return true // Placeholder - integrate with approval system
}
